--// === Service Initialization ===
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualUser = game:GetService("VirtualUser")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local Request = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request)
local Executor = identifyexecutor and identifyexecutor() or "Unknown"

--// === UI Initialization ===
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local MainUI = Rayfield:CreateWindow({
    Name = "Learzy Hub | " .. Executor,
    Theme = "Amethyst",
    ToggleUIKeybind = "K",
})

--// === UI Tabs ===
local tabPlayer = MainUI:CreateTab("Player", 4483362458)
local tabVisual = MainUI:CreateTab("Visual", 4483362458)
local tabCombat = MainUI:CreateTab("Combat", 4483362458)
local tabVehicle = MainUI:CreateTab("Vehicle", 4483362458)
local tabObby = MainUI:CreateTab("Obby", 4483362458)

tabPlayer:CreateParagraph({Title = "Player", Content = "Movement tools available below"})
tabVisual:CreateParagraph({Title = "Visual", Content = "ESP options below"})

--// === Obby State & Toggle ===
local Obby_Enabled = false
tabObby:CreateToggle({
    Name = "Enable Obby Auto-Farm + Rebirth",
    CurrentValue = false,
    Callback = function(state)
        Obby_Enabled = state
        if state then
            startObby()
        end
    end
})

--// === Fly ===
local Fly_Enabled = false
local Fly_Speed = 60
local BodyGyro, BodyVelocity, FlyConnection
local character, humanoidRootPart
local noclippedParts = {}

local function EnableNoclip()
    table.clear(noclippedParts)
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide then
            noclippedParts[part] = true
            part.CanCollide = false
        end
    end
end

local function RestoreCollision()
    for part in pairs(noclippedParts) do
        if part and part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
    table.clear(noclippedParts)
end

local function GetInputDirection()
    local direction = Vector3.zero
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then direction += Vector3.new(0, 0, -1) end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then direction += Vector3.new(0, 0, 1) end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then direction += Vector3.new(-1, 0, 0) end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then direction += Vector3.new(1, 0, 0) end
    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then direction += Vector3.new(0, 1, 0) end
    if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then direction += Vector3.new(0, -1, 0) end
    return direction
end

local function StartFly()
    character = LocalPlayer.Character
    if not character then return end
    humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    EnableNoclip()

    BodyGyro = Instance.new("BodyGyro")
    BodyGyro.P = 9e4
    BodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    BodyGyro.CFrame = humanoidRootPart.CFrame
    BodyGyro.Parent = humanoidRootPart

    BodyVelocity = Instance.new("BodyVelocity")
    BodyVelocity.Velocity = Vector3.zero
    BodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    BodyVelocity.Parent = humanoidRootPart

    FlyConnection = RunService.RenderStepped:Connect(function()
        if not Fly_Enabled then return end
        local cameraCF = Camera.CFrame
        local moveVec = GetInputDirection()
        if moveVec.Magnitude == 0 then
            local hum = character:FindFirstChildOfClass("Humanoid")
            moveVec = hum and hum.MoveDirection or Vector3.zero
        end
        if moveVec.Magnitude > 0 then
            local worldVec = cameraCF:VectorToWorldSpace(moveVec)
            BodyVelocity.Velocity = worldVec.Unit * Fly_Speed
        else
            BodyVelocity.Velocity = Vector3.zero
        end
        BodyGyro.CFrame = cameraCF
        EnableNoclip()
    end)
end

local function StopFly()
    Fly_Enabled = false
    if FlyConnection then FlyConnection:Disconnect() end
    if BodyGyro then BodyGyro:Destroy() end
    if BodyVelocity then BodyVelocity:Destroy() end
    RestoreCollision()
end

tabPlayer:CreateToggle({
    Name = "Fly",
    CurrentValue = false,
    Callback = function(state)
        Fly_Enabled = state
        if state then StartFly() else StopFly() end
    end
})

tabPlayer:CreateSlider({
    Name = "Fly Speed",
    Range = {16, 200},
    Increment = 1,
    Suffix = " studs/s",
    CurrentValue = Fly_Speed,
    Callback = function(value)
        Fly_Speed = value
    end
})

-- === Obby System ===
local function Notify(title, text, duration)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = duration or 5,
    })
end

local function enableGodMode(hum)
    hum.Health = hum.MaxHealth
    hum:GetPropertyChangedSignal("Health"):Connect(function()
        if hum.Health < hum.MaxHealth then
            hum.Health = hum.MaxHealth
        end
    end)
    hum.BreakJointsOnDeath = false
end

local function getCurrentStage()
    local stats = LocalPlayer:FindFirstChild("leaderstats")
    if stats then
        local stageVal = stats:FindFirstChild("Stage") or stats:FindFirstChild("Level")
        if stageVal and stageVal:IsA("IntValue") then
            return stageVal.Value + 1
        end
    end
    return 1
end

local function getLimitedPath(hrp)
    local checkpoints = {}
    for _, part in ipairs(workspace:GetDescendants()) do
        if part:IsA("Part") then
            local stageNum = tonumber(part.Name:match("%d+"))
            if stageNum and stageNum >= getCurrentStage() and stageNum <= getCurrentStage() + 4 then
                table.insert(checkpoints, {
                    part = part,
                    stage = stageNum,
                    dist = (hrp.Position - part.Position).Magnitude
                })
            end
        end
    end
    local closest = {}
    for _, data in ipairs(checkpoints) do
        if not closest[data.stage] or data.dist < closest[data.stage].dist then
            closest[data.stage] = data
        end
    end
    local path = {}
    for _, v in pairs(closest) do table.insert(path, v) end
    table.sort(path, function(a, b) return a.stage < b.stage end)
    return path
end

local function tweenPath(hrp, path)
    for _, node in ipairs(path) do
        local part = node.part
        if not part then continue end
        local targetPos = part.Position + Vector3.new(0, 3, 0)
        local dist = (hrp.Position - targetPos).Magnitude
        local tween = game:GetService("TweenService"):Create(hrp, TweenInfo.new(dist / 40, Enum.EasingStyle.Linear), {CFrame = CFrame.new(targetPos)})
        tween:Play()
        local completed = false
        tween.Completed:Connect(function() completed = true end)
        local timeout = tick() + 5
        while not completed and tick() < timeout do task.wait(0.05) end
        hrp.CFrame = CFrame.new(targetPos)
        firetouchinterest(hrp, part, 0)
        task.wait(0.1)
        firetouchinterest(hrp, part, 1)
        local waitTO = tick() + 5
        while getCurrentStage() <= node.stage and tick() < waitTO do task.wait(0.1) end
        task.wait(0.2)
    end
end

local rebirthPending = false
local function tryRebirth(hrp)
    if rebirthPending then return end
    if getCurrentStage() - 1 <= 0 then
        rebirthPending = true
        Notify("🎉 Rebirth Triggered!", "Stage 0 reached — rebirthing...", 5)
        local remote = game:GetService("ReplicatedStorage"):WaitForChild("MainRemote")
        pcall(function()
            remote:FireServer({Request = "SetStage", Stage = 251})
            task.wait(0.3)
            remote:FireServer({Request = "StageHop", Delta = 10})
            task.wait(0.3)
            remote:FireServer({Request = "Purchase", Type = "RebirthProduct"})
        end)
        task.delay(8, function()
            rebirthPending = false
            if Obby_Enabled then
                startObby()
            end
        end)
    end
end

local stageGui = Instance.new("ScreenGui", game:GetService("CoreGui"))
local label = Instance.new("TextLabel", stageGui)
label.Size = UDim2.new(0, 300, 0, 30)
label.Position = UDim2.new(0, 20, 0, 40)
label.BackgroundTransparency = 0.3
label.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
label.TextColor3 = Color3.fromRGB(255, 255, 255)
label.Font = Enum.Font.SourceSansBold
label.TextSize = 20
label.TextXAlignment = Enum.TextXAlignment.Left

function startObby()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    enableGodMode(hum)

    task.spawn(function()
        while Obby_Enabled do
            local path = getLimitedPath(hrp)
            if #path == 0 then
                Notify("⚠️ No Checkpoint", "No path found. Halting.", 5)
                break
            end
            tweenPath(hrp, path)
            tryRebirth(hrp)
            task.wait(0.2)
        end
    end)

    task.spawn(function()
        while Obby_Enabled do
            local stage = getCurrentStage() - 1
            label.Text = "Stage Sekarang: " .. stage .. " | Selanjutnya: " .. (stage + 1)
            task.wait(0.3)
        end
        label.Text = ""
    end)
end
